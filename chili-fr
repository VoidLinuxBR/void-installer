#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  chili-fr - Wrapper lite para o qemu
#  Created: 2019/12/13 - 00:00
#  Altered: 2024/10/03 - 00:00
#  Updated: dom 07 dez 2025 23:06:48 -04
#
#  Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-fr
export TERM=${TERM:-xterm}
export TERM=${TERM:-xterm-256color}

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e

#system
readonly APP="${0##*/}"
readonly VERSION='2.12.7-20251207'
readonly APPDESC='Wrapper lite para o qemu'
readonly -a DEPENDENCIES=(
	'tput'
	'gettext'
	'qemu-system-x86_64'
	'spice-vdagent'
	'remote-viewer'
	'python3'
	'virsh'
	'find'
	'awk'
	'brctl'
)
readonly -A PACKAGEDEP=(
	['tput']='ncurses'
	['gettext']='gettext'
	['qemu-system-x86_64']='qemu-full'
	['spice-vdagent']='spice-vdagent'
	['remote-viewer']='virt-viewer'
	['python3']='python'
	['virsh']='libvirt'
	['find']='findutils'
	['awk']='gawk'
	['brctl']='bridge-utils'
)

declare HOME_DIR="$HOME/.chili-fr"
declare iface_bridge='br0'
declare bridge=false
declare xmem='8G'
declare videodevice='qxl'
declare videodevice='virtio-vga'
declare videodevice='VGA'
declare spice=false
declare drive=false
declare uefi=false
declare vdisk=false
declare vdisk_name=''
declare netdevice='virtio-net-pci'
declare anetdevices=()
declare netchoosedriver=false
declare LC_DEFAULT=0
declare -i lastrow=$(tput lines)
declare -i lastcol=$(tput cols)
declare -i Prow=0
declare -i Pcol=0
declare -a qemu_options=()
declare -a avdisk_names=()
trap cleanup_working_dir EXIT

function cleanup_working_dir {
	if [[ -d "${working_dir}" ]]; then
		rm -rf -- "${working_dir}"
	fi
}

sh_setvarcolors() {
	if command -v "tput" &>/dev/null; then
		tput sgr0 # reset colors
		bold=$(tput bold)
		reset=$(tput sgr0)
		rst=$(tput sgr0)
		white="${bold}$(tput setaf 7)"
		black="${bold}$(tput setaf 0)"
		red=$(tput bold)$(tput setaf 196)
		green=$(tput setaf 2)
		yellow=$(tput bold)$(tput setaf 3)
		blue=$(tput setaf 4)
		pink=$(tput setaf 5)
		cyan=$(tput setaf 6)
		orange=$(tput setaf 3)
		purple=$(tput setaf 125)
		violet=$(tput setaf 61)
	else
		red="\033[01;31m"
		green="\033[01;32m"
		yellow="\033[01;33m"
		blue="\033[01;34m"
		pink="\033[01;35m"
		cyan="\033[01;36m"
		reset="\033[0m"
	fi
	COL_NC='\e[0m' # No Color
	COL_LIGHT_GREEN='\e[1;32m'
	COL_LIGHT_RED='\e[1;31m'
#  TICK="${white}[${COL_LIGHT_GREEN}✓ OK${COL_NC}${white}]"
#	CROSS="${white}[${COL_LIGHT_RED}✗ERR${COL_NC}${white}]"
#	INFO="[i]"
    : "${clrkey=${light_white}}"
    : "${TICK="${clrkey}[${green}✓✓✓${clrkey}]${rst}"}"
    : "${CROSS="${clrkey}[${red}✗✗✗${clrkey}]${rst}"}"
    : "${MID="${clrkey}[${red}✗✗${green}✓${clrkey}]${rst}"}"
    : "${WARN="${clrkey}[${yellow}⚠  ${clrkey}]${yellow}"}"
    : "${INFO="${clrkey}[${yellow}➡  ${clrkey}]${rst}"}"
	# shellcheck disable=SC2034
	DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
	OVER="\\r\\033[K"
	DOTPREFIX="  ${black}::${reset} "
}

create_menu_with_array() {
	local title=$1
	local -a options=("${!2}") # Recebe o array de opções
	local default=${3:-}       # Opção padrão, se fornecida
	local selected=0
	local key

   options+=("Encerrar")
	# Define a opção padrão como selecionada inicialmente
	if [[ -n "$default" ]]; then
		for i in "${!options[@]}"; do
			if [[ "${options[$i]}" == "$default" ]]; then
				selected=$i
				break
			fi
		done
	fi

	tput civis # Esconde o cursor

	while true; do
		tput clear # Limpa a tela
		echo -e "${blue}${bold}$title${rst}\n"

		for i in "${!options[@]}"; do
			if [[ "$i" -eq $selected ]]; then
				if [[ "${options[$i]}" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
					echo -e "${red}${bold}${reverse}> ${options[$i]}${rst}"
				else
					echo -e "${green}${bold}${reverse}> ${options[$i]}${rst}"
				fi
			else
				if [[ "${options[$i]}" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
					echo -e "${red}  ${options[$i]}${rst}"
				else
					echo "  ${options[$i]}"
				fi
			fi
		done

		read -rsn1 key
		case "$key" in
		A)
			((selected--))
			[ $selected -lt 0 ] && selected=$((${#options[@]} - 1))
			;;
		B)
			((selected++))
			[ $selected -eq ${#options[@]} ] && selected=0
			;;
		'') break ;;
		esac
	done

	tput cnorm # Mostra o cursor novamente
#	echo -e "\nVocê selecionou: ${green}${bold}${options[$selected]}${rst}"
	MENU_RESULT=${options[$selected]}
   if [[ "$MENU_RESULT" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
      die "$MENU_RESULT"
   fi
	#	return $((selected+1))
}

get() {
	local row="$1"
	local col="$2"
	local prompt="$3"
	local new_value="$4"
	local old_value="$5"
	local color="${Acores[box]}"

	# setpos "$row" "$col"
	printf "%s" "${reset}$color"
	read -p "${prompt}${reverse}" -e -i "$old_value" "$new_value"
	# tput sc # Salva a posição atual do cursor
	echo -n -e "$reset"
}

row() { echo "$Prow"; }
col() { echo "$Pcol"; }
lastrow() { echo "$(tput lines)"; }
lastcol() { echo "$(tput cols)"; }

setpos() {
	local row="$1"
	local col="$2"

	Prow="$row"
	Pcol="$col"
	# tput cup "$row" "$col"
	printf "\e[$((row + 1));$((col + 1))H"
}

sh_unsetvarcolors() {
	unset bold reset cyan red blue white black
	unset green yellow orange pink cyan purple violet
}

die() {
  local msg="$1"
  shift
  printf "%b %s\n" "${CROSS}" "${red}${msg}${rst}"
  exit 1
}

log_err() {
  printf "%b %s\n" "${CROSS}" "${*}"
}

log_ok() {
  printf "%b %s\n" "${TICK}" "${*}"
}

log_msg() {
	local retval="${PIPESTATUS[0]}"
	local pcount=$#

	((pcount >= 2)) && {
		retval=$1
		shift
	}
	if [[ $retval -eq 0 ]]; then
		printf "%b %s\n" "${TICK}" "${*}"
	else
		printf "%b %s\n" "${CROSS}" "${*}"
	fi
}

msg_raw() {
	local msg="$1"
	# Remove tags HTML, se existirem
	#msg="$(sed 's/<[^>]*>//g' <<< "$msg")"

	# Verifica se existe ':' na mensagem
	if [[ "$msg" == *:* ]]; then
		# Divide a string antes e depois do primeiro ':'
		local before_colon="${msg%%:*}:"
		local after_colon="${msg#*: }"
		# Aplica as cores
		msg="${cyan}${before_colon} ${red}${after_colon}${reset}"
	else
		# Se não houver ':', aplica apenas a cor padrão
		msg="${yellow}${cyan}${msg}${reset}"
	fi
	echo -e "$msg"
}
export -f msg_raw

msg() {
	local msg="$1"
	msg="$(sed 's/<[^>]*>//g' <<<"$msg")" # Remove as tags HTML
	echo -e "  =>${cyan}running: ${yellow}${msg}${reset}"
}
export -f msg

msg_ok() {
	local msg="$1"
	msg="$(sed 's/<[^>]*>//g' <<<"$msg")" # Remove as tags HTML
	echo -e "  =>${cyan}feito: ${green}${msg}${reset}"
}
export -f msg_ok

msg_run() {
	local msg="$1"
	echo -e "BP=>${cyan}running: ${yellow}${msg}${reset}"
	eval "$msg"
}
export -f msg_run

#msg_info() {
#	local msg="$*"
#	#local caller_function="${FUNCNAME[1]}" # Nome da função que chamou a função atual
#	#local caller_line="${BASH_LINENO[1]}"  # Número da linha que chamou a função atual
#	#echo -e "${caller_function}=>${yellow}info   : ${cyan}${msg}${reset}"
#	#echo -e "${reset}  =>${yellow}info   : ${cyan}${msg}${reset}"
#	printf "%s\n" "${yellow}[WARN] ${cyan}$msg${rst}"
#}
#export -f msg_info

#msg_info() {  printf "%s\n" "${white}${pink}[INFO] ${rst}${*}${rst}"; }
msg_info()     { echo -e "${INFO} ${*}${reset}"; }
msg()          { echo -e "${INFO} ${*}${reset}"; }
log_ok()       { echo -e "${TICK} ${*}${reset}"; }
log_err()      { echo -e "${CROSS} ${*}${reset}"; }
log_mid()      { echo -e "${MID} ${*}${reset}"; }
log_warn()     { echo -e "${WARN} ${*}${reset}"; }
msg_info_tab() { echo -e "  ${INFO} ${*}${reset}"; }
msg_tab()      { echo -e "  ${INFO} ${*}${reset}"; }
log_ok_tab()   { echo -e "  ${TICK} ${*}${reset}"; }
log_err_tab()  { echo -e "  ${CROSS} ${*}${reset}"; }
log_mid_tab()  { echo -e "  ${MID} ${*}${reset}"; }
log_warn_tab() { echo -e "  ${WARN} ${*}${reset}"; }
die() {
  echo -e "${CROSS} ${red}${*}${reset}"
  exit 1
}



msg_warning() {
	local msg="$*"
	#local caller_function="${FUNCNAME[1]}" # Nome da função que chamou a função atual
	#local caller_line="${BASH_LINENO[1]}"  # Número da linha que chamou a função atual
	msg="$(sed 's/<[^>]*>//g' <<<"$msg")"  # Remove as tags HTML
	#echo -e "${caller_function}=>${red}warning: ${orange}${msg}${reset}"
	echo -e "  =>${yellow}warning: ${cyan}${msg}${reset}"
}
export -f msg_warning

msg_warn() {
	local msg="$1"
	#local caller_function="${FUNCNAME[1]}" # Nome da função que chamou a função atual
	#local caller_line="${BASH_LINENO[1]}"  # Número da linha que chamou a função atual
	#msg="$(sed 's/<[^>]*>//g' <<<"$msg")"  # Remove as tags HTML
	#echo -e "${caller_function}=>${red}warning: ${orange}${msg}${reset}"
	#echo -e "  =>${yellow}warning: ${cyan}${msg}${reset}"
	printf "%s\n" "${yellow}[WARN] ${cyan}$msg${rst}"
}
export -f msg_warn

# Função para exibir mensagens informativas
msg_err() {
	printf "%s\n" "${red}[ERRO] ${cyan}$1${rst}"
}

replicate() {
	local char=${1:-'#'}
	local nsize=${2:-$(tput cols)}
	local ccolor=${3:-$green}
	local line
	printf -v line "%*s" "$nsize" && echo -e "${ccolor}${line// /$char}${rst}"
}
export -f replicate

maxcol() {
  COLUMNS=$(stty size)
  COLUMNS=${COLUMNS##* }
  ((COLUMNS <= 0)) && COLUMNS=80
  echo "$COLUMNS"
}

readconf() {
	local msg="$1"
	local color="${2:-${red}}"

	echo -n -e "$color"
	if [[ $LC_DEFAULT -eq 0 ]]; then
		read -r -p "$msg [S/n]"
	else
		read -r -p "$msg [Y/n]"
	fi
	echo -n -e "$reset"
	case "${REPLY^}" in
	[SY]) return 0 ;;
	"") return 0 ;;
	*) return 1 ;;
	esac
}

sh_checkDependencies() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		if ! command -v "$d" &>/dev/null; then
			log_err "Check: ${red}ERROR${reset}: $(gettext "Não foi possível encontrar o comando") ${cyan}'$d'${reset} -> $(gettext "instalar pacote") ${cyan}"${PACKAGEDEP[$d]}"${reset}"
			missing+=("$d")
			errorFound=true
		else
			#log_msg "Check: ${cyan}$d"
			:
		fi
	done

	if $errorFound; then
		replicate '='
		echo "${yellow}             $(gettext "IMPOSSÍVEL CONTINUAR")"
		echo "${black}$(gettext "Este script precisa dos comandos listados acima")"
		echo "${black}$(gettext "Instale-os e/ou verifique se eles estão em seu") ${red}\$PATH${reset}"
		replicate '='
		#die $(gettext "Abortando...")
		if readconf "Deseja instalar os pacotes e criar os arquivos necessários ?"; then
			sh_setup
		fi
	fi
}
export -f sh_checkDependencies

sh_checkVdiskFiles() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	aBlock_files+=($HOME_DIR/vdisk/sda.img)
	aBlock_files+=($HOME_DIR/vdisk/sdb.img)
	aBlock_files+=($HOME_DIR/vdisk/sdc.img)
	aBlock_files+=($HOME_DIR/vdisk/sdd.img)
	aBlock_files+=($HOME_DIR/vdisk/vda.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdb.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdc.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdd.qcow2)
	for d in "${aBlock_files[@]}"; do
		if [[ ! -e "$d" ]]; then
			sh_createVdiskFiles
			break
		fi
	done
}

sh_checkOVMFFiles() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	aBlock_files+=('/usr/share/edk2/x64/OVMF_CODE.4m.fd')
	aBlock_files+=('/usr/share/edk2/x64/OVMF_VARS.4m.fd')
	for d in "${aBlock_files[@]}"; do
		if [[ ! -e "$d" ]]; then
			log_err "Check: ${red}ERROR${reset}: Não foi possível encontrar o arquivo ${cyan}'$d'${yellow} -> instalar pacote ${cyan}edk2-ovmf${reset}"
			errorFound=true
			break
		else
			true
			log_msg "Check: ${cyan}$d"
			:
		fi
	done

	if $errorFound; then
		replicate '='
		echo "${yellow}             $(gettext "FALHA DO CHECK LIST FILE")"
		echo "${black}$(gettext "Este script precisa dos arquivos para UEFI listados acima")"
		echo "${black}$(gettext "Instale-os e/ou verifique se eles estão em ${yellow}/usr/share/edk2/x64/${reset}")"
		echo "${black}$(gettext "Ao decidir não instalar, o UEFI poderá não funcionar corretamente.")${reset}"
		replicate '='
		if readconf "Deseja instalar o pacote e suprir arquivos necessários ?"; then
			sudo pacman -S --quiet --noconfirm edk2-ovmf 1>/dev/null
		fi
	fi
}

######################################################################################################

# Função para verificar se a interface TAP já existe e retornar o próximo número disponível
get_next_free_tap() {
	local next_tap=1
	while ip link show "tap$next_tap" &>/dev/null; do
		next_tap=$((next_tap + 1))
	done
	echo "tap$next_tap"
}

# Função para verificar se a bridge existe e retornar o próximo nome disponível
get_next_free_bridge() {
	local base_bridge="virbr"
	local next_bridge=1
	while ip link show "$base_bridge$next_bridge" &>/dev/null; do
		next_bridge=$((next_bridge + 1))
	done
	echo "$base_bridge$next_bridge"
}

# ---------------------------
# cmd_sudo wrapper
# ---------------------------
cmd_sudo() {
   if [[ $EUID -eq 0 ]]; then
      "$@"
   else
      sudo "$@"
   fi
}

######################################################################################################
#  BRIDGE REAL (tipo VirtualBox) – sem NAT (versão final com get() + loops de validação)
######################################################################################################
create_real_bridge() {
  local bridge_name="$1"
  local iface_phys
  local old_con
  local kernel_master
  local use_dhcp=false
  local bridge_ip
  local bridge_gw

  [[ -z "$bridge_name" ]] && { msg_err "Uso correto: --create_real_bridge br0"; return 1; }

  msg_info "Verificando se a bridge '$bridge_name' já existe"
  if ip link show "$bridge_name" &>/dev/null; then
    msg_warning "Bridge '${bridge_name}' já existe — nada a fazer."
    cmd_sudo nmcli connection show
    return 0
  fi

  ###########################################################################
  # DETECTAR INTERFACES FÍSICAS (ETHERNET)
  ###########################################################################
  msg_info "Detectando interfaces físicas (ethernet)"
  local -a eth_list
  mapfile -t eth_list < <(
    nmcli -t -f DEVICE,TYPE device | awk -F: '$2=="ethernet"{print $1}'
  )

  if [[ ${#eth_list[@]} -eq 0 ]]; then
    msg_err "Nenhuma interface ethernet disponível. WLAN não suporta bridge real."
    return 1
#  elif [[ ${#eth_list[@]} -eq 1 ]]; then
#    iface_phys="${eth_list[0]}"
#    msg_info "Apenas uma interface física encontrada: $iface_phys"
  else
    msg_info "Múltiplas interfaces encontradas — exibindo menu de seleção"
    create_menu_with_array "Escolha a interface física para a bridge:" eth_list[@]
    iface_phys="$MENU_RESULT"
    if [[ "$iface_phys" == "Encerrar" ]]; then
      msg_info "Operação cancelada pelo usuário."
      return 1
    fi
    msg_info "Interface selecionada: $iface_phys"
  fi

  ###########################################################################
  # PROTEÇÃO — INTERFACE NÃO PODE SER WLAN
  ###########################################################################
  if nmcli -t -f DEVICE,TYPE device | grep -q "^${iface_phys}:wifi$"; then
    msg_err "A interface '$iface_phys' é Wi-Fi. Bridge real não funciona com WLAN."
    return 1
  fi

  ###########################################################################
  # VERIFICAR SE INTERFACE JÁ É SLAVE
  ###########################################################################
  msg_info "Verificando se '$iface_phys' já pertence a outra bridge"
  kernel_master=$(ip -o link show "$iface_phys" | sed -n 's/.*master \([^ ]*\).*/\1/p' || true)
  if [[ -n "$kernel_master" ]]; then
    msg_err "Interface '$iface_phys' já pertence à bridge '$kernel_master'."
    msg_warning "Remova primeiro: chili-fr -r $kernel_master"
    return 1
  fi

  ###########################################################################
  # MENU VLAN
  ###########################################################################
  msg_info "Configuração de VLAN"
  local -a vlan_options=(
    "Sem VLAN (rede normal)"
    "VLAN Tagged (criar ${iface_phys}.<id> e usar como slave)"
    "VLAN Trunk (bridge vlan-filtering habilitado)"
  )
  create_menu_with_array "Selecione o modo VLAN:" vlan_options[@]

  local vlan_choice
  case "$MENU_RESULT" in
    "Sem VLAN (rede normal)") vlan_choice="none" ;;
    "VLAN Tagged (criar ${iface_phys}.<id> e usar como slave)") vlan_choice="tagged" ;;
    "VLAN Trunk (bridge vlan-filtering habilitado)") vlan_choice="trunk" ;;
    *) msg_err "Erro inesperado no menu VLAN"; return 1 ;;
  esac
  msg_info "Modo VLAN selecionado: $vlan_choice"

  local vlan_id="" slave_iface="" want_vlan_trunk=false
  if [[ "$vlan_choice" == "tagged" ]]; then
    while true; do
      get 0 0 "Digite o VLAN ID (1–4094): " vlan_id ""
      if [[ "$vlan_id" =~ ^[0-9]+$ && "$vlan_id" -ge 1 && "$vlan_id" -le 4094 ]]; then
        slave_iface="${iface_phys}.${vlan_id}"
        msg_info "Subinterface VLAN definida: $slave_iface"
        break
      fi
      msg_err "VLAN inválida: informe um número entre 1 e 4094."
    done

  elif [[ "$vlan_choice" == "trunk" ]]; then
    want_vlan_trunk=true
    msg_info "Bridge atuará como trunk (vlan-filtering)."

    local vlan_list_raw
    while true; do
      get 0 0 "Informe VLANs permitidas separadas por vírgula (ex: 10,20,30): " vlan_list_raw ""
      vlan_list_raw="${vlan_list_raw// /}"
      IFS=',' read -r -a trunk_vlans <<< "$vlan_list_raw"
      local ok=true
      declare -A _seen=()
      for v in "${trunk_vlans[@]}"; do
        if ! [[ "$v" =~ ^[0-9]+$ && "$v" -ge 1 && "$v" -le 4094 ]]; then
          msg_err "VLAN inválida: $v"
          ok=false
          break
        fi
        if [[ -n "${_seen[$v]}" ]]; then
          msg_err "VLAN duplicada: $v"
          ok=false
          break
        fi
        _seen[$v]=1
      done
      [[ "$ok" == true ]] && break
    done
  fi

  ###########################################################################
  # CAPTURAR IP/GW
  ###########################################################################
  if [[ -n "$slave_iface" ]]; then
    msg_info "Tentando detectar IP na subinterface VLAN '$slave_iface'"
    bridge_ip=$(nmcli -g IP4.ADDRESS device show "$slave_iface" 2>/dev/null | head -n1 || true)
    bridge_gw=$(nmcli -g IP4.GATEWAY device show "$slave_iface" 2>/dev/null | head -n1 || true)
    if [[ -z "$bridge_ip" ]]; then
      msg_info "Usando IP da interface física '$iface_phys'"
      bridge_ip=$(nmcli -g IP4.ADDRESS device show "$iface_phys" | head -n1)
      bridge_gw=$(nmcli -g IP4.GATEWAY device show "$iface_phys")
    fi
  else
    msg_info "Obtendo IP atual da interface '$iface_phys'"
    bridge_ip=$(nmcli -g IP4.ADDRESS device show "$iface_phys" | head -n1)
    bridge_gw=$(nmcli -g IP4.GATEWAY device show "$iface_phys")
  fi

  if [[ -z "$bridge_ip" ]]; then msg_warning "Nenhum IP detectado automaticamente."; fi
  if [[ -z "$bridge_gw" ]]; then msg_warning "Nenhum gateway detectado."; fi

  local original_ip_pure="${bridge_ip%%/*}"

  ###########################################################################
  # SOLICITAR E VALIDAR IP
  ###########################################################################
  msg_info "Configurando IP da bridge '$bridge_name'"

  if readconf "Usar DHCP?"; then
    use_dhcp=true
  else
    while true; do
      get 0 0 "IP (ex 192.168.2.70/24): " tmp_ip "$bridge_ip"
      bridge_ip="${tmp_ip:-$bridge_ip}"

      if [[ ! "$bridge_ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]]; then
        msg_err "Formato inválido."
        continue
      fi

      local candidate_ip="${bridge_ip%%/*}"

      if [[ "$candidate_ip" == "$original_ip_pure" ]]; then
        msg_info "IP igual ao atual — pulando teste."
        break
      fi

      msg_info "Validando se IP está em uso..."
      if command -v arping >/dev/null 2>&1; then
        if cmd_sudo arping -c2 -w1 -I "$iface_phys" "$candidate_ip" >/dev/null 2>&1; then
          msg_err "Conflito ARP detectado."
          continue
        else
          break
        fi
      fi

      break
    done

    while true; do
      get 0 0 "Gateway (ex 192.168.2.1): " tmp_gw "$bridge_gw"
      bridge_gw="${tmp_gw:-$bridge_gw}"

      if [[ ! "$bridge_gw" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        msg_err "Gateway inválido."
        continue
      fi

      if ! ping -c1 -W1 "$bridge_gw" >/dev/null; then
        msg_warning "Gateway não respondeu."
        readconf "Continuar?" && break || continue
      fi

      break
    done
  fi

  ###########################################################################
  # CRIAR BRIDGE E SLAVE
  ###########################################################################
  msg_info "Criando bridge '$bridge_name'"
  cmd_sudo nmcli connection add type bridge ifname "$bridge_name" con-name "$bridge_name" \
    stp no ipv6.method ignore autoconnect yes >/dev/null || { msg_err "Falha ao criar bridge"; return 1; }

  local slave_to_use
  if [[ -n "$slave_iface" ]]; then
    if ! ip link show "$slave_iface" &>/dev/null; then
      msg_info "Criando subinterface VLAN $slave_iface"
      cmd_sudo nmcli connection add type vlan ifname "$slave_iface" dev "$iface_phys" id "$vlan_id" \
        con-name "vlan-${iface_phys}.${vlan_id}" ipv4.method disabled ipv6.method ignore >/dev/null || {
          msg_err "Falha ao criar VLAN"
          return 1
        }
      sleep 1
    fi
    slave_to_use="$slave_iface"
  else
    slave_to_use="$iface_phys"
  fi

   # criar slave da bridge apontando para slave_to_use
   msg_info "Criando conexão slave para '$slave_to_use'"
   local slave_name="${bridge_name}-${slave_to_use}-$(uuidgen | cut -c1-8)"

   cmd_sudo nmcli connection add type bridge-slave ifname "$slave_to_use" con-name "$slave_name" \
     master "$bridge_name" autoconnect yes >/dev/null || {
       msg_err "Falha ao criar slave '$slave_name'"
       return 1
     }

  ###########################################################################
  # VLAN TRUNK
  ###########################################################################
  if [[ "$vlan_choice" == "trunk" ]]; then
    msg_info "Ativando vlan-filtering"
    cmd_sudo nmcli connection modify "$bridge_name" bridge.vlan-filtering yes

    for v in "${trunk_vlans[@]}"; do
      msg_info "Adicionando VLAN $v ao trunk"
      cmd_sudo bridge vlan add dev "$iface_phys" vid "$v" master "$bridge_name" 2>/dev/null || \
        msg_warning "Falha ao adicionar VLAN $v"
    done
  fi

  ###########################################################################
  # DESATIVAR CONEXÃO ANTIGA
  ###########################################################################
  msg_info "Desativando conexão antiga da interface física"
  old_con=$(nmcli -t -f NAME,DEVICE connection show | grep ":$iface_phys$" | cut -d: -f1 || true)
  if [[ -n "$old_con" ]]; then
    cmd_sudo nmcli connection down "$old_con" &>/dev/null
    cmd_sudo nmcli connection modify "$old_con" connection.autoconnect no
  fi

  ###########################################################################
  # CONFIGURAR IP NA BRIDGE
  ###########################################################################
  if [[ "$use_dhcp" == true ]]; then
    msg_info "Ativando DHCP na bridge"
    cmd_sudo nmcli connection modify "$bridge_name" ipv4.method auto ipv4.never-default no >/dev/null
  else
    msg_info "Aplicando IP manual"
    cmd_sudo nmcli connection modify "$bridge_name" \
      ipv4.method manual \
      ipv4.addresses "$bridge_ip" \
      ipv4.gateway "$bridge_gw" \
      ipv4.dns-search "" \
      ipv6.method ignore >/dev/null
  fi

  ###########################################################################
  # ATIVAR A BRIDGE
  ###########################################################################
  msg_info "Ativando bridge '$bridge_name'"
  cmd_sudo nmcli connection up "$bridge_name" >/dev/null

  ###########################################################################
  # RESUMO
  ###########################################################################
  msg_info_tab "${green}---------- RESUMO ----------${rst}"
  msg_info_tab "Bridge           : ${green}$bridge_name${rst}"
  msg_info_tab "Interface física : ${green}$iface_phys${rst}"
  msg_info_tab "Slave            : ${green}$slave_to_use${rst}"
  msg_info_tab "Conexão slave    : ${green}$slave_name${rst}"

  case "$vlan_choice" in
    none)   msg_info_tab "VLAN             : ${green}nenhuma${rst}" ;;
    tagged) msg_info_tab "VLAN Tagged      : ${green}$vlan_id${rst}" ;;
    trunk)  msg_info_tab "Trunk            : ${green}VLANs ${trunk_vlans[*]}${rst}" ;;
  esac

  if [[ "$use_dhcp" == true ]]; then
    msg_info_tab "IP               : ${green}DHCP${rst}"
  else
    msg_info_tab "IP aplicado      : ${green}$bridge_ip${rst}"
    msg_info_tab "Gateway          : ${green}$bridge_gw${rst}"
  fi

  msg_info_tab "${green}-----------------------------${rst}"
  msg_ok "Bridge '$bridge_name' criada com sucesso."

  return 0
}

remove_real_bridge() {
  local bridge_name="$1"
  local iface_phys
  local slave_con
  local bridge_ip
  local bridge_gw

  [[ -z "$bridge_name" ]] && { msg_err "Uso: chili-fr -r br0"; return 1; }

  msg_info "Removendo bridge '$bridge_name' com segurança (sem derrubar SSH)"

  ###########################################################################
  # DETECTAR INTERFACE FÍSICA SLAVE
  ###########################################################################
   iface_phys=$(ip -o link show | grep -w "master $bridge_name" | awk -F: '{print $2}' | awk '{print $1}')
#   iface_phys=$(
#     ip -o link show \
#     | awk -v br="$bridge_name" '
#         $0 ~ ("master " br) {
#           split($2, a, ":");
#           print a[1];
#           exit;
#         }
#       '
#   )

  if [[ -z "$iface_phys" ]]; then
    msg_err "Não foi possível detectar interface física slave."
    return 1
  fi

  msg_info "Interface física slave detectada: ${cyan}$iface_phys${rst}"

  ###########################################################################
  # ACHAR PERFIL SLAVE (fácil)
  ###########################################################################
   slave_con=$(
      nmcli -t -f NAME,TYPE connection show 2>/dev/null |
      grep -m1 "^${bridge_name}-${iface_phys}.*802-3-ethernet" |
      cut -d: -f1
   )

   if [[ -z "$slave_con" ]]; then
     msg_warning "Nenhum perfil slave encontrado — talvez já removido."
   else
     msg_info "Perfil slave encontrado: ${cyan}$slave_con${rst}"
   fi

  ###########################################################################
  # PEGAR IP E GATEWAY ATUAIS DA BRIDGE
  ###########################################################################
  bridge_ip=$(nmcli -g IP4.ADDRESS device show "$bridge_name" | head -n1)
  bridge_gw=$(nmcli -g IP4.GATEWAY device show "$bridge_name" | head -n1)

  msg_info "IP atual na bridge: ${cyan}${bridge_ip:-nenhum}${rst}"
  msg_info "Gateway: ${cyan}${bridge_gw:-nenhum}${rst}"

  ###########################################################################
  # IDENTIFICAR PERFIL FÍSICO CORRETO  (teu método definitivo)
  ###########################################################################
   phys_con=$(
      nmcli -t -f NAME,DEVICE,TYPE,SLAVE connection show \
         | awk -F: -v dev="$interface" '
        $3 ~ /802-3-ethernet/ && ($2 == dev || $2 == "") && $4 != "bridge" {print $1; exit}
    ')

  if [[ -z "$phys_con" ]]; then
    msg_err "Não foi possível localizar o perfil físico verdadeiro para '$iface_phys'."
    return 1
  fi

  msg_info "Perfil físico real: ${cyan}$phys_con${rst}"

  ###########################################################################
  # RESTAURAR AUTOCONNECT + IP NA FÍSICA (ANTES DE REMOVER A BRIDGE)
  ###########################################################################
  msg_info_tab "Restaurando autoconnect da interface física"
  cmd_sudo nmcli connection modify "$phys_con" connection.autoconnect yes

  if [[ -n "$bridge_ip" ]]; then
    msg_info_tab "Aplicando IP ($bridge_ip) de volta na interface física"
    cmd_sudo nmcli connection modify "$phys_con" ipv4.method manual
    cmd_sudo nmcli connection modify "$phys_con" ipv4.addresses "$bridge_ip"
    [[ -n "$bridge_gw" ]] && cmd_sudo nmcli connection modify "$phys_con" ipv4.gateway "$bridge_gw"
  else
    msg_info_tab "Sem IP detectado — configurando interface física para DHCP"
    cmd_sudo nmcli connection modify "$phys_con" ipv4.method auto
  fi

  ###########################################################################
  # SUBIR INTERFACE FÍSICA AGORA (ANTES DE REMOVER A BRIDGE)
  ###########################################################################
  msg_info_tab "Subindo interface física ANTES de remover a bridge"
  echo -n "$green"
  cmd_sudo nmcli connection up "$phys_con" || msg_warning "Falha ao subir interface física — pode ser esperado via SSH"
  echo -n "$rst"

  ###########################################################################
  # REMOVER PERFIL SLAVE
  ###########################################################################
  if [[ -n "$slave_con" ]]; then
    msg_info_tab "Removendo conexão slave '$slave_con'"
    echo -n "$green"
    cmd_sudo nmcli connection delete "$slave_con"
    echo -n "$rst"
  fi

  ###########################################################################
  # REMOVER A BRIDGE
  ###########################################################################
  msg_info_tab "Desativando bridge '$bridge_name'"
  echo -n "$green"
  cmd_sudo nmcli connection down "$bridge_name" 2>/dev/null
  echo -n "$rst"

  msg_info_tab "Removendo perfil da bridge"
  echo -n "$green"
  cmd_sudo nmcli connection delete "$bridge_name" 2>/dev/null
  echo -n "$rst"

  msg_ok "Bridge '$bridge_name' removida com sucesso e interface '$iface_phys' restaurada."
}

create_bridge_virbr() {
	local bridge_name="$1"

  if sudo virsh -c qemu:///system net-list --all &>/dev/null; then
    msg_info "virsh está funcionando e conseguiu listar as redes."
  else
    msg_warning "virsh não conseguiu se conectar ao libvirt."
    msg_warning "Verifique se o serviço libvirtd está ativo com os comandos abaixo:\n\
sudo systemctl status libvirtd.service
sudo systemctl status libvirtd.socket"
    msg_warning "DICA: Tente ativar com os comandos abaixo:\n\
sudo systemctl enable --now libvirtd virtqemud
sudo systemctl restart libvirtd.service"
  die "Erro fatal"
  fi

	if [[ -z "$bridge_name" ]]; then
		# Obter o próximo nome de bridge disponível
		bridge_name=$(get_next_free_bridge)
	fi

	# Criar a rede virsh correspondente à nova bridge
	if sudo virsh net-list --all 1>/dev/null; then
		if ! sudo virsh net-list --all | grep -q "$bridge_name" 1>/dev/null; then
			msg_info "Criando a rede $bridge_name..."

			# Calcular a faixa de IP com base no nome da bridge
			# O número da bridge será extraído (ex: virbr1 -> 1, virbr2 -> 2, etc.)
			bridge_number=$(echo "$bridge_name" | grep -o '[0-9]*')
			base_ip="172.$((30 + bridge_number)).255.1"
			GATEWAY="$base_ip"
			subnet="255.255.255.0"
			dhcp_range_start="172.$((30 + bridge_number)).255.2"
			dhcp_range_end="172.$((30 + bridge_number)).255.200"

			# Criando o arquivo de configuração temporário para a rede
			tmp_net_config=$(mktemp)

			cat <<EOF >"$tmp_net_config"
<!--
WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:
  virsh net-edit $bridge_name
or other application using the libvirt API.
-->

<network>
  <name>$bridge_name</name>
  <uuid>$(uuidgen)</uuid>
  <forward mode='nat'/>
  <bridge name='$bridge_name' stp='on' delay='0'/>
  <ip address='$base_ip' netmask='$subnet'>
    <dhcp>
      <range start='$dhcp_range_start' end='$dhcp_range_end'/>
    </dhcp>
  </ip>
</network>
EOF
			# Definir a rede usando o arquivo temporário
			sudo virsh net-define "$tmp_net_config" 1>/dev/null
			# Remover o arquivo de configuração temporário após a definição
			sudo rm -f "$tmp_net_config"
		fi
	else
		die "erro fatal!"
	fi

	# Tornar a nova bridge persistente
	msg_info "Tornando $bridge_name persistente..."
	msg_info "Iniciando a rede $bridge_name..."
	sudo virsh net-autostart "$bridge_name" 1>/dev/null

	if ! sudo virsh net-start "$bridge_name" 1>/dev/null; then
		msg_err "Falha ao iniciar a rede $bridge_name. Tentando novamente."
		sudo virsh net-destroy "$bridge_name" 1>/dev/null
		sudo virsh net-start "$bridge_name" 1>/dev/null
	fi

	# Obter o próximo nome de interface TAP disponível
	#tap_name=$(get_next_free_tap)-"$bridge_name"
	tap_name="tap-$bridge_name"

	# Criar a interface TAP (ex: tap0, tap1, tap2...)
	msg_info "Criando a interface TAP $tap_name..."
	sudo ip tuntap add dev "$tap_name" mode tap 1>/dev/null

	# Colocar a interface TAP para up
	msg_info "Ativando a interface TAP $tap_name..."
	sudo ip link set "$tap_name" up 1>/dev/null

	# Adicionar a interface TAP à bridge recém-criada
	msg_info "Adicionando $tap_name à bridge $bridge_name..."
	sudo brctl addif "$bridge_name" "$tap_name" 1>/dev/null

	# Verificar se a bridge e o TAP foram configurados corretamente
	msg_info "Verificando a associação de interfaces à bridge $bridge_name..."
	brctl show "$bridge_name" 1>/dev/null

	# Exibir as interfaces para verificar se tudo está funcionando
	msg_info "Verificando as interfaces de rede..."
	ip addr show "$bridge_name" 1>/dev/null
	ip addr show "$tap_name" 1>/dev/null

	sudo virsh net-info "$bridge_name"
	msg_info "Configuração concluída!"
	exit
}

remove_virbr_bridge_and_tap() {
	local bridge_name="$1"
	local tap_name

	#tap_name="tap$(echo "$bridge_name" | sed 's/[^0-9]*//g')" # Ajuste para pegar o número correto do tap
	tap_name="tap-$bridge_name"

	# Remover a bridge
	msg_info "Removendo a bridge $bridge_name..."
	sudo ip link set "$bridge_name" down 1>/dev/null
	sudo brctl delbr "$bridge_name" 1>/dev/null

	# Remover a interface TAP associada
	if ip link show "$tap_name" &>/dev/null; then
		msg_info "Removendo a interface TAP $tap_name..."
		sudo ip link set "$tap_name" down 1>/dev/null
		sudo ip tuntap del dev "$tap_name" mode tap 1>/dev/null
	else
		msg_err "A interface TAP $tap_name não existe."
	fi

	# Remover a rede do libvirt
	msg_info "Removendo a rede do libvirt..."
	sudo virsh net-destroy "$bridge_name" 1>/dev/null
	sudo virsh net-autostart --disable "$bridge_name" 1>/dev/null
	sudo virsh net-undefine "$bridge_name" 1>/dev/null
	sudo ip link delete "$bridge_name" 1>/dev/null
	sudo systemctl restart libvirtd 1>/dev/null

	# Remover a configuração da rede do libvirt, caso fique residuos
	local network_config="/etc/libvirt/qemu/networks/${bridge_name}.xml"
	local network_config_autostart="/etc/libvirt/qemu/networks/autostart/${bridge_name}.xml"
	msg_info "Removendo o arquivo de configuração da rede $bridge_name..."
	sudo rm -fv "$network_config" 1>/dev/null
	sudo rm -fv "$network_config_autostart" 1>/dev/null

	sudo virsh net-info "$bridge_name" 1>/dev/null
	msg_ok "Bridge $bridge_name e TAP $tap_name removidos com sucesso."
	exit 0
}

######################################################################################################

# Função para obter as interfaces do tipo bridge usando brctl
get_bridge_interfaces() {
	#brctl show | awk 'NR > 1 {printf "%s ", $1}'
	brctl show | awk 'NR > 1 {printf "%s ", $1}' | sed 's/ $//'
}

# Função para obter os arquivos RAW no diretório $HOME_DIR/vdisk/
get_raw_images() {
	local dir="${HOME_DIR:-$HOME}/vdisk"
	# Lista os arquivos com extensão .img, removendo o caminho e separando por espaço
	#  find "$dir" -maxdepth 1 -type f -name "*.img" -exec basename {} \; | tr '\n' ' ' | sed 's/ $//'
	find "$dir" -maxdepth 1 -type f \( -name "*.img" -o -name "*.qcow2" \) -exec basename {} \; | tr '\n' ' ' | sed 's/ $//'
}

supports_uefi() {
	fdisk -l "$1" 2>/dev/null | grep -q "EFI"
}

detect_audio_server() {
	if pgrep -x pipewire >/dev/null; then
		echo "pipewire"
	elif pgrep -x pulseaudio >/dev/null; then
		echo "pa"
	elif pgrep -x jackd >/dev/null; then
		echo "jack"
	else
		echo "none"
	fi
}

sh_version() {
	cat <<-EOF
		${bold}${cyan}${0##*/} v${VERSION}${rst}
		${APPDESC}
		${VERSION}
		${bold}${black}Copyright (C) 2019-2025 ChiliLinux Development Team${black}
		${bold}${black}Copyright (C) 2019-2025 Vilmar Catafesta${black}

		  Este é um software livre: você é livre para alterá-lo e redistribuí-lo.
		  O $APP é disponibilizado para você sob a ${yellow}Licença MIT${black}, e
		  inclui software de código aberto sob uma variedade de outras licenças.
		  Você pode ler instruções sobre como baixar e criar para você mesmo
		  o código fonte específico usado para criar esta cópia.
		  ${red}Este programa vem com absolutamente NENHUMA garantia.
		  ${rst}
	EOF
	exit 0
}

function sh_usage {
	cat <<EOF
uso: ${orange}$APP${reset} [Opções]
${cyan}$(gettext "Opções"):${reset}
  ${rst}-b|--bridge ${orange}<bridge_name>              ${cyan}# inicia rede em modo bridge - ex: -b br0 (default: NAT)
  ${rst}-c|--create_real_bridge ${orange}<bridge_name>  ${cyan}# criar real bridge - ex: -c br0
  ${rst}-r|--remove_real_bridge ${orange}<bridge_name>  ${cyan}# remover real bridge - ex: -r br0
  ${rst}--create_virbr_bridge ${orange}<bridge_name>    ${cyan}# criar virbr bridge - ex: -c br0
  ${rst}--remove_virbr_bridge ${orange}<bridge_name>    ${cyan}# remover virbr bridge - ex: -r br0
  ${rst}-d|--drive ${orange}<drive_path>                ${cyan}# anexa disco externo - ex: -d /dev/sdX (default: none)
  ${rst}-m|--memory ${orange}<mem>                      ${cyan}# memória inicial de convidado - ex: -m 16G (default: 8GB)
  ${rst}-v|--vdisk ${orange}<filename.img|qcow2>        ${cyan}# usa um disco virtual interno - ( default: none)
  ${rst}   --cvdisk ${orange}<filename>                 ${cyan}# cria um disco virtual para uso interno
  ${rst}   --rvdisk ${orange}<filename>                 ${cyan}# remove um disco virtual
  ${rst}-g|--video ${orange}<video_driver>              ${cyan}# virtio-vga,virtio-gpu-pci,qxl-vga,VGA,cirrus-vga,ati-vga,virtio-gpu-pci,bochs-display - default: VGA
  ${rst}-N|--network ${orange}<net_driver>              ${cyan}# virtio-net-pci,e1000,rtl8139,vmxnet3 (default: virtio-pc)
  ${rst}-n|--nocolor                           ${cyan}# remover cores da saída - (default: color)
  ${rst}-s|--spice                             ${cyan}# ativar o spice - (default: desligado)
  ${rst}-l|--list                              ${cyan}# listar discos virtuais
  ${rst}-u|--uefi                              ${cyan}# inicialização em UEFI - (default: BIOS)
  ${rst}-V|--version                           ${cyan}# exibe a versão do aplicativo
  ${rst}-h|--help                              ${cyan}# imprime este ajuda
${cyan}$(gettext "Exemplo"):${rst}
  $ ${orange}$APP${reset} -u -b br0 file.iso          ${cyan}#$(gettext "Execute uma imagem, em ponte, usando") UEFI ${rst}
  $ ${orange}$APP${reset} -u -s -b br0 file.iso       ${cyan}#$(gettext "Execute uma imagem, em ponte, usando spice, usando") UEFI ${rst}
  $ ${orange}$APP${reset} -u file.img                 ${cyan}#$(gettext "Execute uma imagem, em NAT, usando") UEFI ${rst}
  $ ${orange}$APP${reset} -b br0 /dev/sdX             ${cyan}#$(gettext "Execute uma device, em ponte, usando") UEFI ${rst}
  $ ${orange}$APP${reset} -u -m 16G -b br0 /dev/sdX   ${cyan}#$(gettext "Execute uma device, em ponte, 16Gb memória, usando") UEFI ${rst}
  $ ${orange}$APP${reset} -a pipewire /dev/sdX        ${cyan}#$(gettext "Execute uma device, em NAT, usando audio pipewire") ${rst}
  $ ${orange}$APP${reset} file.iso                    ${cyan}#$(gettext "Execute uma imagem usando") BIOS${rst}
  $ ${orange}$APP${reset} -b file.img                 ${cyan}#$(gettext "Execute uma imagem, em ponte, usando") BIOS ${rst}
  $ ${orange}$APP${reset} -m 16G /dev/sdX             ${cyan}#$(gettext "Execute uma device, 16GB memória, usando") BIOS ${rst}
${cyan}Forma de uso mais comum:${rst}
  $ ${orange}$APP${reset} filename.iso ${rst}
  $ ${orange}$APP${reset} -u filename.iso ${rst}
  $ ${orange}$APP${reset} /dev/sdX ${rst}
  $ ${orange}$APP${reset} -u /dev/sdX ${rst}
  $ ${orange}$APP${reset} -d /dev/sdX filename.iso ${rst}
  $ ${orange}$APP${reset} -u -d /dev/sdX filename.iso ${rst}
  $ ${orange}$APP${reset} -v vdisk_name.img filename.iso ${rst}
  $ ${orange}$APP${reset} -u -v vdisk_name.img filename.iso ${rst}
  $ ${orange}$APP${reset} $HOME_DIR/vdisk/vdisk_name.img ${rst}
${cyan}acesso a vm/convidado via ssh:${rst}
  $ ${reset} ssh live@vsock/555             ${cyan}# via vsock ${rst}
  $ ${reset} ssh live@127.0.0.1 -p 60022    ${cyan}# via redirecionamento ${rst}
  $ ${reset} ssh $USER@127.0.0.1 -p 60022   ${cyan}# via redirecionamento ${rst}
  $ ${reset} ssh <ip_vm>                    ${cyan}# via bridge (caso vm iniciada com -b) ${rst}
  ${reset}
EOF
	exit 0
}

sh_createVdiskFiles() {
	local aBlockDisk=(sda.img sdb.img sdc.img sdd.img)
	local aBlockDiskQcow2=(vda.qcow2 vdb.qcow2 vdc.qcow2 vdd.qcow2)
	local file

	if [[ ! -d "$HOME_DIR/vdisk/" ]]; then
		msg_info "Criando diretórios de trabalho"
		mkdir -p "$HOME_DIR/vdisk/" &>/dev/null
	fi

	msg_info "Setando permissões no diretórios de trabalho"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null

	for file in "${aBlockDisk[@]}"; do
		if [[ ! -e $HOME_DIR/vdisk/$file ]]; then
			msg_info "Criando disco virtual '$file' no diretórios de trabalho"
			qemu-img create $HOME_DIR/vdisk/$file -f raw 32G &>/dev/null
		fi
	done
	for file in "${aBlockDiskQcow2[@]}"; do
		if [[ ! -e $HOME_DIR/vdisk/$file ]]; then
			msg_info "Criando disco virtual '$file' no diretórios de trabalho"
			qemu-img create -f qcow2 $HOME_DIR/vdisk/$file 32G &>/dev/null
		fi
	done
}

sh_setup() {
	msg_info "Instalando necessários pacotes"
	sudo pacman -S --needed --quiet --noconfirm \
		qemu-full \
		edk2-ovmf \
		ncurses \
		gettext \
		spice-vdagent \
		virt-viewer \
		python \
		libvirt \
		findutils \
    gawk \
    bridge-utils \
		seabios 1>/dev/null

	sh_createVdiskFiles
	sh_start_vdagentd
}

sh_create_vdisk_file() {
	msg_info "Criando diretórios de trabalho"
	mkdir -p "$HOME_DIR/vdisk" &>/dev/null
	msg_info "Setando permissões no diretórios de trabalho"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null
	sudo chown $USER:$USER "$HOME_DIR/" -R &>/dev/null

	while true; do
		sh_list_vdisks
		get 10 10 "Entre com o nome do disco (sem extensão) - ex vda  : " cvdisk_name
		get 11 10 "Entre com o tamanho do disco virtual em GB - ex 32 : " cvdisk_size

		if test -e $HOME_DIR/vdisk/$cvdisk_name.img &>/dev/null; then
			if readconf "Disco virtual já existe, escolha outro nome. Tentar novamente?"; then
				continue
			fi
		else
			if qemu-img create $HOME_DIR/vdisk/$cvdisk_name.img -f raw "$cvdisk_size"G &>/dev/null; then
				msg_ok "Disco virtual '$HOME_DIR/vdisk/$cvdisk_name.img' criado com sucesso"
				echo -n $green
				ls -lh $HOME_DIR/vdisk
				echo -n $rst
				replicate '='
			else
				die "Falha na criação do disco virtual $HOME_DIR/vdisk/$cvdisk_name.img"
			fi
		fi
		break
	done
}

sh_list_vdisks() {
	replicate "================== DISCOS VIRTUAIS DISPONÍVEIS em $HOME_DIR/vdisk ===================" 1
	echo -n $green
	ls -lh $HOME_DIR/vdisk
	echo -n $rst
	replicate '='
}

sh_remove_vdisk_file() {
	msg_info "Criando diretórios de trabalho"
	mkdir -p "$HOME_DIR/vdisk" &>/dev/null
	msg_info "Setando permissões no diretórios de trabalho"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null
	sudo chown $USER:$USER "$HOME_DIR/" -R &>/dev/null

	sh_list_vdisks
	get 10 10 "Entre com o nome do disco para remover - ex vda.img : " cvdisk_name

	if test -e $HOME_DIR/vdisk/$cvdisk_name &>/dev/null; then
		if readconf "PERGUNTA: Deseja realmente excluir o disco virtual ?"; then
			if rm -f $HOME_DIR/vdisk/$cvdisk_name &>/dev/null; then
				msg_ok "Disco virtual '$HOME_DIR/vdisk/$cvdisk_name' foi removido com sucesso"
				exit 0
			fi
		fi
		exit $?
	else
		die "Disco virtual digitado não existe"!
	fi
}

sh_start_vdagentd() {
	if ! pgrep spice-vdagentd; then
		msg_info "Ativando o serviço spice-vdaagentd"
		sudo systemctl enable -now spice-vdagentd &>/dev/null
	fi
}

main() {
	#	local img="$1"
	local params=("$@")
	local img
	local random_port="$(shuf -i 4444-45000 -n 1)"
	local random_spice_port="$(shuf -i 5900-5910 -n 1)"
	local cache_type
	local bootindex
	local media_type
	local count=1
	local devices=()

	for img in "${params[@]}"; do
		# Verificar se a imagem foi especificada
		[[ -z "$img" ]] && {
			sh_list_vdisks
			die "Erro: vdisk/iso/device #${count} não especificada!"
		}
		if [[ ! -e "$img" ]]; then
			[[ ! -e "$HOME_DIR/vdisk/$img" ]] && {
				log_msg 1 "Check: ${yellow}dispositivo #${count}: ${cyan}$img"
				sh_list_vdisks
				die "Erro: vdisk/iso/device #${count} ${cyan}${img} ${red}não localizada, tente os listados acima!${reset}"
			}
			img="$HOME_DIR/vdisk/$img"
		fi
		devices+=("$img")
		log_msg true "Check: ${yellow}dispositivo #${count}: ${cyan}$img"
		((++count))
	done

	# Forçar UEFI, se solicitado
	if $uefi; then
  	sh_checkOVMFFiles
	  msg_info "Forçando inicialização UEFI..."
		#[[ ! -e $HOME_DIR/OVMF_VARS.4m.fd ]] && cp -f /usr/share/edk2-ovmf/x64/OVMF_VARS.4m.fd $HOME_DIR/
		cp -f /usr/share/edk2-ovmf/x64/OVMF_VARS.4m.fd $HOME_DIR/
		qemu_options+=(-drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2/x64/OVMF_CODE.4m.fd)
		qemu_options+=(-drive if=pflash,format=raw,file=$HOME_DIR/OVMF_VARS.4m.fd)
	else
		msg_warn "Parametro --uefi não informado, usando BIOS legacy (padrão)..."
	fi

	# Adicionar opções padrão do QEMU
	qemu_options+=(-no-fd-bootchk)
	qemu_options+=(-machine accel=kvm)
	qemu_options+=(-cpu host)
	qemu_options+=(-smp "$(nproc)")
	qemu_options+=(-m ${xmem})
	qemu_options+=(-k pt-br)

	#Modo	            Vantagens	                                              Desvantagens
	#cache=none	      Seguro, evita inconsistências	                          Pode ser mais lento
	#cache=writeback	Boa performance, mantém um nível aceitável de segurança	Risco de perda de dados em caso de falha
	#cache=directsync	Segurança máxima (grava direto no disco)	              Muito mais lento
	#cache=unsafe	    Máxima performance	                                    Pode corromper dados se houver falha

	cache_type='writeback'
	bootindex=1 # Índice de boot inicial

	for img in "${devices[@]}"; do
		media_type=$(file -b --mime-type "${img}")
#		qemu_options+=(-boot menu=on)
		if [[ "${media_type}" == "application/x-iso9660-image" ]]; then
			msg_info "Anexando iso #${bootindex}: ${yellow}${img}"
			qemu_options+=(-drive file="${img}",if=none,id=cdrom${bootindex},media=cdrom)
			qemu_options+=(-device ide-cd,drive=cdrom${bootindex},bootindex=${bootindex})
			((bootindex++))
		elif [[ "${img}" == *.qcow2 ]]; then
			msg_info "Anexando vdisk #${bootindex}: ${yellow}${img}"
			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=qcow2,cache=${cache_type})
			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
			((bootindex++))
		elif [[ "${img}" == /dev/* ]]; then
			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw,media=disk,cache=${cache_type})
			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
			msg_info "Anexando device #${bootindex}: ${yellow}${img}"
			((bootindex++))
		else
			msg_info "Anexando vdisk #${bootindex}: ${yellow}${img}"
#			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw,cache=${cache_type})
#			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
      qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw)
      qemu_options+=(-device ahci,id=sata${bootindex})
      qemu_options+=(-device ide-hd,drive=disk${bootindex},bus=sata${bootindex}.0,bootindex=${bootindex})
			((bootindex++))
		fi
	done

	if $vdisk; then
		for vdsk in "${avdisk_names[@]}"; do
			[[ ! -e "$vdsk" ]] && vdsk="$HOME_DIR/vdisk/$vdsk"
			[[ ! -e "$vdsk" ]] && continue

			if [[ "${vdsk}" == *.img ]]; then
				msg_info "Anexando vdisk #${bootindex}: ${yellow}${vdsk}"
				qemu_options+=(-drive file="${vdsk}",if=none,id=disk${bootindex},format=raw,cache=${cache_type})
				qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
				((bootindex++))
			elif [[ "${vdsk}" == *.qcow2 ]]; then
				msg_info "Anexando vdisk #${bootindex}: ${yellow}${vdsk}"
				qemu_options+=(-drive file="${vdsk}",if=none,id=disk${bootindex},format=qcow2,cache=${cache_type})
				qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
				((bootindex++))
			fi
		done
	else
#		msg_warn "Parametro --vdisk não informado, iniciando sem disco virtual..."
		:
	fi

#	qemu_options+=(-name "chili-fr $*",process=archiso_0)
  qemu_options+=(-name "chili-fr")
	qemu_options+=(-device virtio-scsi-pci,id=scsi0)
	qemu_options+=(-audiodev "$(detect_audio_server)",id=snd0)
	qemu_options+=(-rtc base=localtime,clock=host)
	qemu_options+=(-device ich9-intel-hda)
	qemu_options+=(-device hda-output,audiodev=snd0)
	qemu_options+=(-global ICH9-LPC.disable_s3=1)
	qemu_options+=(-machine type=q35,smm=on,accel=kvm,usb=on,pcspk-audiodev=snd0)
	#	qemu_options+=(-device intel-iommu)
	qemu_options+=(-device virtio-serial)
	#video

  qemu_options+=(-device "$videodevice")
  qemu_options+=(-display gtk,gl=on)

	if $spice; then
		sh_start_vdagentd

		# Informar as portas usadas
		msg_info "spice running on port: $random_spice_port"
		msg_info "remote-viewer spice://localhost:$random_spice_port"

		# Configurar SPICE
		qemu_options+=(-spice port=$random_spice_port,disable-ticketing=on)
		qemu_options+=(-monitor tcp:localhost:$random_port,server,nowait)
		#qemu_options+=(-chardev spicevmc,id=vdagent,debug=0,name=vdagent)
		#qemu_options+=(-device virtserialport,chardev=vdagent,name=com.redhat.spice.0)
		qemu_options+=(-chardev spicevmc,id=charchannel0,name=vdagent)
		qemu_options+=(-device virtserialport,chardev=charchannel0,name=com.redhat.spice.0)

		# Executar o QEMU
		sudo env XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}" &
		qemu_pid=$!
		remote-viewer spice://localhost:$random_spice_port &
		viewer_pid=$!

		# Aguardar o remote-viewer e encerrar o QEMU quando ele fechar
		wait $viewer_pid
		kill $qemu_pid &>/dev/null
  else
		msg_info "spice running on port: ${yellow}$random_spice_port"
		msg_info "remote-viewer spice://localhost:$random_spice_port"

      qemu_options+=(
         -device virtio-serial
		   -spice port=$random_spice_port,disable-ticketing=on
         -chardev spicevmc,id=vdagent,name=vdagent
         -device virtserialport,chardev=vdagent,name=com.redhat.spice.0
         -display none
      )

      # echo "${qemu_options[@]}" ; exit
      sudo env XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}" &
      qemu_pid=$!
      remote-viewer "spice://localhost:$random_spice_port" &
      viewer_pid=$!
      wait $viewer_pid
      kill $qemu_pid &>/dev/null
      exit 0
   fi
}
export -f main

sh_copyright() {
	echo -n $orange
	echo "$APP - v${VERSION} - ${APPDESC}"
	echo 'Copyright (c) 2019-2025, ChiliLinux Development Team <https://chililinux.com> <https://github.com/chililinux>'
	echo 'Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>'
	echo $rst
}

print_avaiable_bridges() {
   local bridges=( $(get_bridge_interfaces) )

   echo -e "${cyan}disponíveis:${rst}"
   if [[ ${#bridges[@]} -eq 0 ]]; then
      echo -e "  ${yellow}(nenhuma bridge disponível)${rst}"
   else
      for b in "${bridges[@]}"; do
         echo -e "  ${yellow}${b}${rst}"
      done
   fi
}

sh_setvarcolors
#sh_copyright

# Display usage information if no arguments are passed
if [[ $# -eq 0 || $1 == @(-h|--help) ]]; then
	sh_usage
fi
if [[ $1 == @(-V|--version) ]]; then
	sh_version
fi

sh_checkDependencies
sh_checkVdiskFiles

OPTIONS=m:ub:Vnhd:sg:v:i:N:c:r:l
LONGOPTIONS=memory:,uefi,bridge:,version,nocolor,help,drive:,spice,video:,image:,network:,create_virbr_bridge:,remove_virbr_bridge:,create_real_bridge:,remove_real_bridge:,cvdisk,rvdisk,vdisk,list
opts=($(getopt --options="$OPTIONS" --longoptions="$LONGOPTIONS" --name "$0" -- "$@"))
eval set -- "${opts[*]}"

while test ${#opts[*]} -gt 0; do
	case $1 in
	-n | --nocolor)
		sh_unsetvarcolors
		;;
	-u | --uefi)
		uefi=true
		;;
	-i | --image)
		if [[ -z "$2" ]]; then
			die "Argumento inválido para ${1}, falta parâmetro de imagem/disco/device" >&2
		else
			img="$2"
			shift
		fi
		;;
	-c | --create_real_bridge)
		if [[ -z "$2" ]]; then
			die "Argumento inválido para --create_real_bridge. Ex: --create_real_bridge br0"
		else
			create_real_bridge "$2"
			exit 0
		fi
		;;
   -r | --remove_real_bridge)
      if [[ " $(get_bridge_interfaces) " =~ " $2 " ]]; then
         bridge_name="$2"
         remove_real_bridge "$bridge_name"
         exit 0
      else
         echo -e "${red}Erro:${rst} Argumento inválido para ${cyan} ${1} ${rst}" >&2
         print_avaiable_bridges
         exit 1
      fi
      ;;
	--create_virbr_bridge)
		if [[ -z "$2" ]]; then
			die "Argumento inválido para --create_virbr_bridge, falta nome para bridge \nEx.: --create_virbr_bridge br0" >&2
   	else
			if [[ " $(get_bridge_interfaces) " =~ " $2 " ]]; then
				die "Argumento inválido para ${cyan}--create_virbr_bridge${red}. BRIDGE ${cyan}$2 ${red}já existe" >&2
			else
				bridge_name="$2"
				create_virbr_bridge "$bridge_name"
				shift
			fi
		fi
		;;
	--remove_virbr_bridge)
		if [[ " $(get_bridge_interfaces) " =~ " $2 " ]]; then
			bridge_name="$2"
			remove_virbr_bridge_and_tap "$bridge_name"
			shift
		else
         echo -e "${red}Erro:${rst} Argumento inválido para ${cyan}${1}${rst}" >&2
         print_avaiable_bridges
         exit 1
		fi
		;;
	-b | --bridge)
		if [[ " $(get_bridge_interfaces) " =~ " $2 " ]]; then
			iface_bridge="$2"
			msg_info "Parametro --bridge detectado: tentando usar bridge '$iface_bridge'"
			bridge=true
			shift
		else
         echo -e "${red}Erro:${rst} Argumento inválido para ${cyan}${1}${rst}" >&2
         print_avaiable_bridges
         exit 1
		fi
		;;
	-s | --spice)
		spice=true
		log_msg "Parametro --spice detectado: tentando usar spice..."
		;;
	-g | --video)
		if [[ $2 =~ ^(virtio-vga|virtio-gpu-pci|qxl-vga|VGA|cirrus-vga|ati-vga|virtio-gpu-pci|bochs-display|ramfb)?$ ]]; then
			videodevice="$2"
			shift
		else
			die "$(gettext "Argumento inválido para -v. Use VGA,virtio-vga,virtio-gpu-pci,qxl-vga,cirrus-vga,ati-vga,virtio-gpu-pci,bochs-display ou ramfb")" >&2
		fi
		;;
	-l | --list)
    sh_list_vdisks
    exit 0
    :
		;;
	-v | --vdisk)
		if [[ " $(get_raw_images) " =~ " $2 " || -e "$2" ]]; then
			vdisk_name="$2"
			avdisk_names+=("$vdisk_name")
			vdisk=true
			shift
		else
			sh_list_vdisks
			die "Argumento inválido para ${cyan}--vdisk ${rst}Válidos são: ${yellow}$(get_raw_images)${rst}" >&2
		fi
		;;
	--cvdisk)
		sh_create_vdisk_file
		exit $?
		;;
	--rvdisk)
		sh_remove_vdisk_file
		exit $?
		;;
	-N | --network)
		if [[ $2 =~ ^(virtio-net-pci|e1000|rtl8139|vmxnet3|ne2k_pci|ne2k_isa|pcnet|smc91c111|i82551|i82557b|i82559er)?$ ]]; then
			netdevice="$2"
			anetdevices+=("$netdevice")
			netchoosedriver=true
			msg_info "Anexando placa de rede, driver: ${yellow}$netdevice"
			shift
		else
			die "Argumento inválido para --network. Use virtio-net-pci,e1000,rtl8139,vmxnet3,ne2k_pci,ne2k_isa,pcnet,smc91c111,i82551,i82557b,i82559er" >&2
		fi
		;;
	-d | --drive)
		if [[ -n $2 ]]; then
			drive=true
			drive_path=$2
			if lsblk $drive_path &>/dev/null; then
				log_msg "Parametro -d,--drive detectado: $drive_path"
			else
				die "${cyan}Parametro -d,--drive => ${red}$drive_path: não é um dispositivo de bloco"
			fi
			shift
		else
			die "$(gettext "Argumento inválido para --drive. Use formato device, como /dev/sdX (por exemplo).")" >&2
		fi
		;;
	-m | --memory)
		if [[ $2 =~ ^[0-9]+[MG]?$ ]]; then
			xmem=$2
			log_msg "Parametro -m/--memory detectado: $2"
			shift
		else
			die "$(gettext "Argumento inválido para -m. Use um formato como 16G (por exemplo).")" >&2
		fi
		;;
	--)
		shift
		break
		;;
	:)
		die "-$OPTARG $(gettext "requer um argumento")" >&2
		;;
	*)
		die "$(gettext "operação não suportada"): $1 ($(gettext "usar -h para ajuda"))"
		;;
	esac
	shift
done

if [[ $# > 0 ]]; then
	# Configurar rede
	#random_mac_net0=$(python3 -c "import random; print(':'.join(['{:02x}'.format(random.randint(0, 255)) for _ in range(6)]))")
	#random_mac_net1=$(python3 -c "import random; print(':'.join(['{:02x}'.format(random.randint(0, 255)) for _ in range(6)]))")
	#qemu_options+=(-netdev bridge,id=net0,smb=$HOME)
	#qemu_options+=(-netdev bridge,id=net0)
	#qemu_options+=(-device e1000,netdev=net0)
	#qemu_options+=(-device e1000,netdev=net0,mac=$random_mac_net0)
	#qemu_options+=(-netdev bridge,id=net1,br=$iface_bridge)
	#qemu_options+=(-device e1000,netdev=net1,mac=$random_mac_net1)
	#qemu_options+=(-netdev tap,ifname=tap1,script=no,downscript=no,id=net0)
	#qemu_options+=(-device virtio-net-device,netdev=net0,mac=92:7b:15:c3:4d:ec)

   # intervalo de 555 a 560 → tamanho = 560−555+1 = 6
   export GUEST_CID=$(( RANDOM % 6 + 555 ))
   export HOST_FWD=$(( RANDOM % 6 + 60022 ))
   if $netchoosedriver; then
		for netdevice in "${anetdevices[@]}"; do
			((nId++))
			netdev_id="net$nId"
			if $bridge; then
				qemu_options+=(-netdev bridge,id="$netdev_id",br=$iface_bridge)
			else
			  if $spice; then
  				qemu_options+=(-netdev user,id="$netdev_id")
  			else
  				qemu_options+=(-netdev user,id="$netdev_id",hostfwd=tcp::$HOST_FWD-:22,smb=$HOME/share)
  		  fi
			fi
			qemu_options+=(-device "$netdevice",netdev="$netdev_id")
		done
		qemu_options+=(-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=$GUEST_CID)
      msg_info "acesso a vm/convidado via ssh:"
      msg_info "$  ssh live@vsock/$GUEST_CID               # via vsock"
      msg_info "$  ssh live@127.0.0.1 -p $HOST_FWD      # via redirecionamento"
      msg_info "$  ssh $USER@127.0.0.1 -p $HOST_FWD      # via redirecionamento"
	else
		netdev_id="net0"
		if $bridge; then
			qemu_options+=(-netdev bridge,id="$netdev_id",br=$iface_bridge)
		else
         if $spice; then
  		      qemu_options+=(-netdev user,id="$netdev_id")
  		   else
  		      qemu_options+=(-netdev user,id="$netdev_id",hostfwd=tcp::$HOST_FWD-:22,smb=$HOME/share)
  		   fi
		fi
		qemu_options+=(-device "$netdevice",netdev="$netdev_id")
		qemu_options+=(-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=$GUEST_CID)
      msg_info "acesso a vm/convidado via ssh:"
      msg_info "$  ssh live@vsock/$GUEST_CID               # via vsock"
      msg_info "$  ssh live@127.0.0.1 -p $HOST_FWD      # via redirecionamento"
      msg_info "$  ssh $USER@127.0.0.1 -p $HOST_FWD      # via redirecionamento"
	fi

  #windows
  qemu_options+=(-usb -device usb-tablet)

	if $drive; then
		msg_info "Anexando disco/drive externo: ${yellow}$drive_path"
		qemu_options+=(-drive file=$drive_path,format=raw,media=disk)
	fi
	main "$@"
else
	#	die "${opts[*]} $(gettext "falta parâmetro de imagem/disco/device"): ($(gettext "usar -h para ajuda"))"
	sh_list_vdisks
	die "Erro: Falta parâmetro de imagem/disco/device. ${cyan}Tente os vdisks listados acima. ${yellow}(usar -h para ajuda)
      ${reset}Ex. : ${green}$ ${reset}${APP} ${reset}vda.img"
fi
